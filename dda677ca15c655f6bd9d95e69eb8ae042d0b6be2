{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d3877099_0e36d356",
        "filename": "include/libbej/bej_tree.h",
        "patchSetId": 5
      },
      "lineNbr": 115,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2023-07-04T16:26:08Z",
      "side": 1,
      "message": "Since this is adding the API before a user, I am speculating here.  I anticipate that RDE responders will need to run the BEJ encoder as the encoded lengths are dynamic with the actual value.  \n\nWhile representing an enum as a string is convenient when translating from a JSON string, in a constrained system I would hope to supply an enum value as an integer and avoid having the encoder doing a string comparison each time let alone searching for the matching string in a table.\n\nAs an alternative (to avoid requiring the value provider to have to match the  values from the dictionary) we could have the enum node store an integer and a pointer to a table of struct (string, dictionary enumeration) with a count of elements and a count of pre-matched values.  The encoder would cache the enumerated values.  A resource constrained caller would supply a table with all supported enum values, and a general translator could set a table with one entry.\n\nAnother alternative would be supply two APIs, one enum value based that is the known dictionary (since its defined to be stable across versions) and the keep current proposed string enum value.",
      "revId": "dda677ca15c655f6bd9d95e69eb8ae042d0b6be2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}