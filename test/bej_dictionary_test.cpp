#include "bej_dictionary.h"

#include <array>
#include <string_view>
#include <tuple>

#include <gmock/gmock-matchers.h>
#include <gmock/gmock.h>
#include <gtest/gtest.h>

namespace libbej
{

/**
 * @brief A valid dictionary.
 */
constexpr std::array<uint8_t, 279> dummySimpleDict{
    {0x0,  0x0,  0xc,  0x0,  0x0,  0xf0, 0xf0, 0xf1, 0x17, 0x1,  0x0,  0x0,
     0x0,  0x0,  0x0,  0x16, 0x0,  0x5,  0x0,  0xc,  0x84, 0x0,  0x14, 0x0,
     0x0,  0x48, 0x0,  0x1,  0x0,  0x13, 0x90, 0x0,  0x56, 0x1,  0x0,  0x0,
     0x0,  0x0,  0x0,  0x3,  0xa3, 0x0,  0x74, 0x2,  0x0,  0x0,  0x0,  0x0,
     0x0,  0x16, 0xa6, 0x0,  0x34, 0x3,  0x0,  0x0,  0x0,  0x0,  0x0,  0x16,
     0xbc, 0x0,  0x64, 0x4,  0x0,  0x0,  0x0,  0x0,  0x0,  0x13, 0xd2, 0x0,
     0x0,  0x0,  0x0,  0x52, 0x0,  0x2,  0x0,  0x0,  0x0,  0x0,  0x74, 0x0,
     0x0,  0x0,  0x0,  0x0,  0x0,  0xf,  0xe5, 0x0,  0x46, 0x1,  0x0,  0x66,
     0x0,  0x3,  0x0,  0xb,  0xf4, 0x0,  0x50, 0x0,  0x0,  0x0,  0x0,  0x0,
     0x0,  0x9,  0xff, 0x0,  0x50, 0x1,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7,
     0x8,  0x1,  0x50, 0x2,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7,  0xf,  0x1,
     0x44, 0x75, 0x6d, 0x6d, 0x79, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x0,
     0x43, 0x68, 0x69, 0x6c, 0x64, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50, 0x72,
     0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x0,  0x49, 0x64, 0x0,  0x53, 0x61,
     0x6d, 0x70, 0x6c, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x50,
     0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x0,  0x53, 0x61, 0x6d, 0x70,
     0x6c, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x50, 0x72, 0x6f,
     0x70, 0x65, 0x72, 0x74, 0x79, 0x0,  0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65,
     0x52, 0x65, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79,
     0x0,  0x41, 0x6e, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x42, 0x6f, 0x6f, 0x6c,
     0x65, 0x61, 0x6e, 0x0,  0x4c, 0x69, 0x6e, 0x6b, 0x53, 0x74, 0x61, 0x74,
     0x75, 0x73, 0x0,  0x4c, 0x69, 0x6e, 0x6b, 0x44, 0x6f, 0x77, 0x6e, 0x0,
     0x4c, 0x69, 0x6e, 0x6b, 0x55, 0x70, 0x0,  0x4e, 0x6f, 0x4c, 0x69, 0x6e,
     0x6b, 0x0,  0x0}};

/**
 * @brief Property names and sequence numbers in dummySimpleDict.
 * Order here is the same as the order in the dummySimpleDict.
 */
constexpr std::array<std::tuple<std::string_view, int>, 12> propertyNameSeq{{
    {"DummySimple", 0},
    {"ChildArrayProperty", 0},
    {"Id", 1},
    {"SampleEnabledProperty", 2},
    {"SampleIntegerProperty", 3},
    {"SampleRealProperty", 4},
    {"", 0},
    {"AnotherBoolean", 0},
    {"LinkStatus", 1},
    {"LinkDown", 0},
    {"LinkUp", 1},
    {"NoLink", 2},
}};

TEST(BejDictionaryTest, PropertyHeadOffsetTest)
{
    EXPECT_THAT(bejDictGetPropertyHeadOffset(), sizeof(BejDictionaryHeader));
}

TEST(BejDictionaryTest, AnnotationPropertyHeadOffsetTest)
{
    EXPECT_THAT(bejDictGetFirstAnnotatedPropertyOffset(),
                sizeof(BejDictionaryHeader) + sizeof(BejDictionaryProperty));
}

TEST(BejDictionaryTest, ValidPropertyTest)
{
    const struct BejDictionaryHeader* header =
        (const struct BejDictionaryHeader*)dummySimpleDict.data();
    uint16_t propHead = bejDictGetPropertyHeadOffset();
    // Read each property in the dictionary and verify that the property name is
    // correct.
    for (uint16_t index = 0; index < header->entryCount; ++index)
    {
        uint16_t offset = propHead + sizeof(BejDictionaryProperty) * index;
        const struct BejDictionaryProperty* property;
        uint16_t propertyOffset;
        EXPECT_THAT(bejDictGetProperty(dummySimpleDict.data(), offset,
                                       std::get<1>(propertyNameSeq[index]),
                                       &property, &propertyOffset),
                    0);
        EXPECT_THAT(propertyOffset, offset);
        EXPECT_THAT(bejDictGetPropertyName(dummySimpleDict.data(),
                                           property->nameOffset,
                                           property->nameLength),
                    std::get<0>(propertyNameSeq[index]));
    }
}

TEST(BejDictionaryTest, InvalidPropertyOffsetTest)
{
    const struct BejDictionaryProperty* property;
    EXPECT_THAT(bejDictGetProperty(dummySimpleDict.data(), /*offset=*/0,
                                   /*sequenceNumber=*/0, &property, NULL),
                bejErrorInvalidPropertyOffset);
    uint16_t propHead = bejDictGetPropertyHeadOffset();
    EXPECT_THAT(bejDictGetProperty(dummySimpleDict.data(), propHead + 1,
                                   /*sequenceNumber=*/0, &property, NULL),
                bejErrorInvalidPropertyOffset);
    // Try a property outside of the dictionary property region.
    EXPECT_THAT(
        bejDictGetProperty(dummySimpleDict.data(),
                           propHead + sizeof(struct BejDictionaryProperty) * 20,
                           /*sequenceNumber=*/0, &property, NULL),
        bejErrorInvalidPropertyOffset);
}

constexpr std::array<uint8_t, 701> driveTruncDict{
    {0x0,  0x1,  0x25, 0x0,  0x0,  0xf0, 0xfd, 0xf1, 0xbd, 0x2,  0x0,  0x0,
     0x0,  0x0,  0x0,  0x16, 0x0,  0x5,  0x0,  0x6,  0x7e, 0x1,  0x0,  0x0,
     0x0,  0x48, 0x0,  0x3,  0x0,  0x8,  0x84, 0x1,  0x52, 0xa,  0x0,  0x0,
     0x0,  0x0,  0x0,  0x3,  0x8c, 0x1,  0x56, 0x11, 0x0,  0x0,  0x0,  0x0,
     0x0,  0x6,  0x8f, 0x1,  0x52, 0x12, 0x0,  0x0,  0x0,  0x0,  0x0,  0x5,
     0x95, 0x1,  0x0,  0x1c, 0x0,  0x66, 0x0,  0x2,  0x0,  0x7,  0x9a, 0x1,
     0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4,  0xa1, 0x1,  0x0,  0x1,
     0x0,  0x7a, 0x0,  0x2,  0x0,  0x13, 0xa5, 0x1,  0x0,  0x2,  0x0,  0x8e,
     0x0,  0x3,  0x0,  0xd,  0xb8, 0x1,  0x46, 0x0,  0x0,  0xac, 0x0,  0x3,
     0x0,  0x7,  0xc5, 0x1,  0x46, 0x3,  0x0,  0xca, 0x0,  0x6,  0x0,  0x6,
     0xcc, 0x1,  0x52, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7,  0xd2, 0x1,
     0x52, 0x1,  0x0,  0x0,  0x0,  0x0,  0x0,  0x6,  0xd9, 0x1,  0x52, 0x0,
     0x0,  0x0,  0x0,  0x0,  0x0,  0x7,  0xd2, 0x1,  0x52, 0x1,  0x0,  0x0,
     0x0,  0x0,  0x0,  0x6,  0xd9, 0x1,  0x44, 0x2,  0x0,  0x6,  0x1,  0xc,
     0x0,  0xa,  0xdf, 0x1,  0x50, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x9,
     0xe9, 0x1,  0x50, 0x1,  0x0,  0x0,  0x0,  0x0,  0x0,  0x3,  0xf2, 0x1,
     0x50, 0x2,  0x0,  0x0,  0x0,  0x0,  0x0,  0x8,  0xf5, 0x1,  0x50, 0x1,
     0x0,  0x0,  0x0,  0x0,  0x0,  0x9,  0xfd, 0x1,  0x50, 0x2,  0x0,  0x0,
     0x0,  0x0,  0x0,  0x8,  0x6,  0x2,  0x50, 0x4,  0x0,  0x0,  0x0,  0x0,
     0x0,  0xf,  0xe,  0x2,  0x50, 0x5,  0x0,  0x0,  0x0,  0x0,  0x0,  0xd,
     0x1d, 0x2,  0x50, 0x7,  0x0,  0x0,  0x0,  0x0,  0x0,  0x13, 0x2a, 0x2,
     0x50, 0xa,  0x0,  0x0,  0x0,  0x0,  0x0,  0x9,  0x3d, 0x2,  0x50, 0x0,
     0x0,  0x0,  0x0,  0x0,  0x0,  0x9,  0x46, 0x2,  0x50, 0x1,  0x0,  0x0,
     0x0,  0x0,  0x0,  0x8,  0x4f, 0x2,  0x50, 0x2,  0x0,  0x0,  0x0,  0x0,
     0x0,  0xd,  0x57, 0x2,  0x50, 0x3,  0x0,  0x0,  0x0,  0x0,  0x0,  0x10,
     0x64, 0x2,  0x50, 0x4,  0x0,  0x0,  0x0,  0x0,  0x0,  0x11, 0x74, 0x2,
     0x50, 0x5,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4,  0x85, 0x2,  0x50, 0x6,
     0x0,  0x0,  0x0,  0x0,  0x0,  0x3,  0x89, 0x2,  0x50, 0x7,  0x0,  0x0,
     0x0,  0x0,  0x0,  0x10, 0x8c, 0x2,  0x50, 0x8,  0x0,  0x0,  0x0,  0x0,
     0x0,  0x6,  0x9c, 0x2,  0x50, 0x9,  0x0,  0x0,  0x0,  0x0,  0x0,  0x7,
     0xa2, 0x2,  0x50, 0xa,  0x0,  0x0,  0x0,  0x0,  0x0,  0x8,  0xa9, 0x2,
     0x50, 0xb,  0x0,  0x0,  0x0,  0x0,  0x0,  0xb,  0xb1, 0x2,  0x44, 0x72,
     0x69, 0x76, 0x65, 0x0,  0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x0,
     0x49, 0x64, 0x0,  0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x0,  0x4e, 0x61, 0x6d,
     0x65, 0x0,  0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x0,  0x4f, 0x65, 0x6d,
     0x0,  0x23, 0x44, 0x72, 0x69, 0x76, 0x65, 0x2e, 0x53, 0x65, 0x63, 0x75,
     0x72, 0x65, 0x45, 0x72, 0x61, 0x73, 0x65, 0x0,  0x23, 0x44, 0x72, 0x69,
     0x76, 0x65, 0x2e, 0x52, 0x65, 0x73, 0x65, 0x74, 0x0,  0x48, 0x65, 0x61,
     0x6c, 0x74, 0x68, 0x0,  0x53, 0x74, 0x61, 0x74, 0x65, 0x0,  0x74, 0x61,
     0x72, 0x67, 0x65, 0x74, 0x0,  0x74, 0x69, 0x74, 0x6c, 0x65, 0x0,  0x52,
     0x65, 0x73, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65, 0x0,  0x43, 0x72, 0x69,
     0x74, 0x69, 0x63, 0x61, 0x6c, 0x0,  0x4f, 0x4b, 0x0,  0x57, 0x61, 0x72,
     0x6e, 0x69, 0x6e, 0x67, 0x0,  0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65,
     0x64, 0x0,  0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x0,  0x53, 0x74,
     0x61, 0x6e, 0x64, 0x62, 0x79, 0x4f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65,
     0x0,  0x53, 0x74, 0x61, 0x6e, 0x64, 0x62, 0x79, 0x53, 0x70, 0x61, 0x72,
     0x65, 0x0,  0x55, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c,
     0x65, 0x4f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x0,  0x55, 0x70, 0x64,
     0x61, 0x74, 0x69, 0x6e, 0x67, 0x0,  0x46, 0x6f, 0x72, 0x63, 0x65, 0x4f,
     0x66, 0x66, 0x0,  0x46, 0x6f, 0x72, 0x63, 0x65, 0x4f, 0x6e, 0x0,  0x46,
     0x6f, 0x72, 0x63, 0x65, 0x52, 0x65, 0x73, 0x74, 0x61, 0x72, 0x74, 0x0,
     0x47, 0x72, 0x61, 0x63, 0x65, 0x66, 0x75, 0x6c, 0x52, 0x65, 0x73, 0x74,
     0x61, 0x72, 0x74, 0x0,  0x47, 0x72, 0x61, 0x63, 0x65, 0x66, 0x75, 0x6c,
     0x53, 0x68, 0x75, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x0,  0x4e, 0x6d, 0x69,
     0x0,  0x4f, 0x6e, 0x0,  0x50, 0x75, 0x73, 0x68, 0x50, 0x6f, 0x77, 0x65,
     0x72, 0x42, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x0,  0x50, 0x61, 0x75, 0x73,
     0x65, 0x0,  0x52, 0x65, 0x73, 0x75, 0x6d, 0x65, 0x0,  0x53, 0x75, 0x73,
     0x70, 0x65, 0x6e, 0x64, 0x0,  0x50, 0x6f, 0x77, 0x65, 0x72, 0x43, 0x79,
     0x63, 0x6c, 0x65, 0x0,  0x0}};

TEST(BejDictionaryTest, BejLocatorSuccess)
{
    uint16_t propertyOffset;
    const struct BejDictionaryProperty* property;

    constexpr uint16_t exPropOffset = 92;
    constexpr std::array<uint8_t, 8> bejLocator{
        {0x1, 0x6, 0x1, 0x0, 0x1, 0x0, 0x1, 0x4}};

    EXPECT_THAT(bejDictEntryByBejLocator(driveTruncDict.data(),
                                         bejLocator.data(), bejLocator.size(),
                                         &property, &propertyOffset),
                0);
    EXPECT_THAT(propertyOffset, exPropOffset);
    EXPECT_THAT(std::string(bejDictGetPropertyName(driveTruncDict.data(),
                                                   property->nameOffset,
                                                   property->nameLength)),
                std::string("#Drive.Reset"));
}

TEST(BejDictionaryTest, BejLocatorInvalidLengthBytes)
{
    uint16_t propertyOffset;

    // First nnint gives a wrong length.
    constexpr std::array<uint8_t, 8> bejLocator{
        {0x1, 0x8, 0x1, 0x0, 0x1, 0x0, 0x1, 0x4}};

    EXPECT_THAT(bejDictEntryByBejLocator(driveTruncDict.data(),
                                         bejLocator.data(), bejLocator.size(),
                                         nullptr, &propertyOffset),
                -1);
}

TEST(BejDictionaryTest, BejLocatorInvalidSequenceNumber)
{
    uint16_t propertyOffset;

    constexpr std::array<uint8_t, 8> bejLocator{
        {0x1, 0x6, 0x1, 0x0, 0x1, 0x0, 0x1, 0xFF}};

    EXPECT_THAT(bejDictEntryByBejLocator(driveTruncDict.data(),
                                         bejLocator.data(), bejLocator.size(),
                                         nullptr, &propertyOffset),
                bejErrorUnknownProperty);
}

TEST(BejDictionaryTest, BejLocatorNullOffsetPointer)
{
    const struct BejDictionaryProperty* property;
    constexpr std::array<uint8_t, 8> bejLocator{
        {0x1, 0x6, 0x1, 0x0, 0x1, 0x0, 0x1, 0xFF}};

    EXPECT_THAT(bejDictEntryByBejLocator(driveTruncDict.data(),
                                         bejLocator.data(), bejLocator.size(),
                                         &property, nullptr),
                bejErrorNullParameter);
}

} // namespace libbej
